---
/**
 Local-first responsive image component.

 Expected file naming (pre-generated variants placed under public/images/...):
   base.ext                → original (fallback)
   base.w480.ext           → width 480
   base.w768.ext           → width 768
   base.w1024.ext          → width 1024
   base.w1440.ext          → width 1440
 Optional format siblings per width (if you export them):
   base.w768.webp, base.w768.avif, ...

 Props:
  - src: string (path under public/, e.g., `${import.meta.env.BASE_URL}images/products/pdp/hero.jpg`)
  - alt: string
  - widths?: number[] (default: [480, 768, 1024, 1440])
  - sizes?: string (default: `(max-width: 768px) 100vw, 50vw`)
  - aspect?: string (CSS aspect-ratio, e.g., `16/9`)
  - loading?: 'lazy' | 'eager' (default: 'lazy')
  - priority?: boolean (if true, adds fetchpriority=high and decoding=sync)
  - class?: string; style?: string
  - formats?: string[] (subset of ['avif','webp'] you have generated; default: [])
  - placeholder?: string (data URL or small image URL)
*/
interface Props {
  src: string;
  alt: string;
  widths?: Array<number>;
  sizes?: string;
  aspect?: string;
  loading?: 'lazy' | 'eager';
  priority?: boolean;
  class?: string;
  style?: string;
  formats?: Array<'avif' | 'webp'>;
  placeholder?: string;
}
const p = Astro.props as Props;
const widths = (p.widths && p.widths.length ? p.widths : [480, 768, 1024, 1440]).sort((a,b)=>a-b);
const sizes = p.sizes || '(max-width: 768px) 100vw, 50vw';
const loading = p.loading || (p.priority ? 'eager' : 'lazy');
const fetchpriority = p.priority ? 'high' : 'auto';
const decoding = p.priority ? 'sync' : 'async';
const aspect = p.aspect || '';
const cls = p.class || '';
const st = p.style || '';
const formats = p.formats || [];

function splitExt(url: string): { base: string; ext: string }{
  const i = url.lastIndexOf('.');
  if (i < 0) return { base: url, ext: '' };
  return { base: url.slice(0, i), ext: url.slice(i+1) };
}

const { base, ext } = splitExt(p.src);

function buildSrcSet(forExt: string): string{
  return widths.map(w => `${base}.w${w}.${forExt} ${w}w`).join(', ');
}

const srcsetFallback = buildSrcSet(ext);
const srcFallback = `${base}.w${widths[0]}.${ext}`;
---
<figure class={`mi-wrap ${cls}`} style={`${aspect ? `--mi-aspect:${aspect};` : ''}${st}`}>
  <picture>
    {formats.includes('avif') && <source type="image/avif" srcset={buildSrcSet('avif')} sizes={sizes} />}
    {formats.includes('webp') && <source type="image/webp" srcset={buildSrcSet('webp')} sizes={sizes} />}
    <img
      src={srcFallback}
      srcset={srcsetFallback}
      sizes={sizes}
      alt={p.alt}
      loading={loading}
      decoding={decoding}
      fetchpriority={fetchpriority}
      style={p.placeholder ? 'background-size:cover;background-position:center' : undefined}
    />
  </picture>
  {p.placeholder && <span class="mi-ph" style={`background-image:url('${p.placeholder}')`} aria-hidden="true"></span>}
  <slot />
  {Astro.slots.has('caption') && <figcaption><slot name="caption" /></figcaption>}
</figure>

<style>
  .mi-wrap{position:relative;display:block}
  .mi-wrap::before{content:'';display:block;aspect-ratio:var(--mi-aspect)}
  .mi-wrap picture,.mi-wrap img{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;border-radius:12px}
  .mi-ph{position:absolute;inset:0;background-size:cover;background-position:center;filter:blur(12px) saturate(.9);transform:scale(1.05);z-index:-1}
  figcaption{color:var(--on-muted);font-size:13px;margin-top:6px}
  @supports not (aspect-ratio: 1 / 1){ .mi-wrap::before{display:none} }
  @media (prefers-reduced-motion: reduce){ .mi-ph{filter:blur(8px) saturate(.9)} }
</style>

