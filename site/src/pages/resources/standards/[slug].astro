---
export async function getStaticPaths() {
    const slugs = ['oauth','oidc','pkce','rar','par','jarm','fapi-2-0','scim','ciba','mcp','caep','token-exchange','resource-indicators','dpop','mtls','dcr','authzen'];
	return slugs.map((slug) => ({ params: { slug } }));
}
const { slug } = Astro.params as { slug: string };
import Base from '../../../layouts/Base.astro';
const pretty = slug
  .replace('oidc','OpenID Connect (OIDC)')
  .replace('rar','Rich Authorization Requests (RAR)')
  .replace('par','Pushed Authorization Requests (PAR)')
  .replace('jarm','JARM')
  .replace('fapi-2-0','FAPI 2.0')
  .replace('scim','SCIM')
  .replace('ciba','CIBA')
  .replace('mcp','Model Context Protocol (MCP)')
  .replace('caep','CAEP')
  .replace('token-exchange','Token Exchange (RFC 8693)')
  .replace('resource-indicators','Resource Indicators (RFC 8707)')
  .replace('dpop','DPoP (RFC 9449)')
  .replace('mtls','OAuth mTLS (RFC 8705)')
  .replace('dcr','Dynamic Client Registration (RFC 7591/7592)')
  .replace('authzen','OpenID AuthZEN')
  .replace('oauth','OAuth 2.0');
const title = `${pretty} — Primer`;
const description = 'What it is, why it matters, enforcement points, and how it works.';
const canonical = `/resources/standards/${slug}/`;
---
<Base title={title} description={description} canonical={canonical}>
	<section class="container" style="padding:96px 0 24px">
		<h1 class="display" style="margin:0 0 8px">{title}</h1>
		<p style="color:#9ba3b7">Short, factual overview. Links to docs where relevant.</p>
	</section>
    <section class="container" style="padding:8px 0 80px">
        <div class="glass-card" style="padding:20px;margin-bottom:16px">
            <h2 class="section-title" style="margin:0 0 8px">Why it matters</h2>
            <p style="color:#9ba3b7;margin:0">Standards reduce risk and vendor lock‑in. We implement this spec across our Studios and runtime so policy is portable.</p>
        </div>
        <div class="glass-card" style="padding:20px;margin-bottom:16px">
            <h2 class="section-title" style="margin:0 0 8px">Where it’s enforced</h2>
            <ul style="color:#9ba3b7;line-height:1.8;margin:0">
                <li><strong>Gateway</strong>: pre‑execution gating (plan/schema pins, params/egress)</li>
                <li><strong>Shield</strong>: inline budgets/stream caps/content checks</li>
                <li><strong>PDP</strong>: decisions with constraints/obligations/TTL</li>
                <li><strong>IdP</strong>: passports, token exchange, consent/DPoP</li>
            </ul>
        </div>
        <div class="glass-card" style="padding:20px">
            <h2 class="section-title" style="margin:0 0 8px">How it works (high level)</h2>
            {
                slug === 'token-exchange' && (
                    <>
                        <p style="color:#9ba3b7;margin:0 8px 8px 0">RFC 8693 lets a client exchange one token for another. Inputs include <code>subject_token</code> (required), optional <code>actor_token</code>, and <code>requested_token_type</code>. The AS validates inputs and issues a new token; for OBO, JWTs commonly carry <code>act</code> (actor) and may include <code>may_act</code>.</p>
                        <pre class="glass-card" style="padding:12px;overflow:auto"><code>{`x-www-form-urlencoded
grant_type=urn:ietf:params:oauth:grant-type:token-exchange&
subject_token=...&
subject_token_type=urn:ietf:params:oauth:token-type:access_token&
actor_token=...&
actor_token_type=urn:ietf:params:oauth:token-type:access_token&
requested_token_type=urn:ietf:params:oauth:token-type:access_token&
resource=https://api.example.com/
`}</code></pre>
                        <pre class="glass-card" style="padding:12px;overflow:auto"><code>{`mermaid\nsequenceDiagram\n  autonumber\n  participant C as Client\n  participant AS as Authorization Server (TE)\n  participant RS as Resource Server\n  C->>AS: POST /token (TE: subject_token[, actor_token])\n  AS->>AS: Validate signatures/expiry/audience/types\n  AS-->>C: access_token (may include act.sub; aud set for resource)\n  C->>RS: Use new token to call API`}</code></pre>
                        <p style="color:#9ba3b7;margin-top:8px">Key params: <code>subject_token[_type]</code>, <code>actor_token[_type]</code>, <code>requested_token_type</code>, <code>resource</code> (or AS-specific audience), <code>scope</code>. Output is a normal OAuth token response.</p>
                    </>
                )
            }
            {
                slug === 'resource-indicators' && (
                    <>
                        <p style="color:#9ba3b7;margin:0 0 8px">RFC 8707 defines the <code>resource</code> parameter to indicate the target RS. Values MUST be absolute URIs without fragments. AS issues a token suitable for that resource (often reflected in <code>aud</code>).</p>
                        <pre class="glass-card" style="padding:12px;overflow:auto"><code>{`x-www-form-urlencoded
grant_type=client_credentials&
scope=admin.api&
resource=https://idp.example.com/api/admin
`}</code></pre>
                        <pre class="glass-card" style="padding:12px;overflow:auto"><code>{`mermaid\nsequenceDiagram\n  participant Client\n  participant AS as Authorization Server\n  participant Admin as Admin API\n  Client->>AS: /token (resource=https://.../api/admin)\n  AS-->>Client: access_token (aud matches resource)\n  Client->>Admin: Authorization: Bearer &lt;access_token&gt;`}</code></pre>
                        <p style="color:#9ba3b7;margin-top:8px">Multiple <code>resource</code> values may be sent; the AS selects what it supports. If both vendor <code>audience</code> and <code>resource</code> are sent, follow your AS precedence (RFC recommends <code>resource</code>).</p>
                    </>
                )
            }
            {
                slug === 'dpop' && (
                    <>
                        <p style="color:#9ba3b7;margin:0 0 8px">DPoP (RFC 9449) binds tokens to a client key. Proof JWT header contains the public JWK; payload includes <code>htu</code> (URL), <code>htm</code> (method), <code>iat</code>, <code>jti</code>; RS requests include <code>ath</code> (access token hash). Issued tokens carry <code>cnf.jkt</code>.</p>
                        <pre class="glass-card" style="padding:12px;overflow:auto"><code>{`DPoP: eyJ0eXAiOiJkcG9wK2p3dCIsImFsZyI6IlJTMjU2Iiwia2lkIjoiIiwiamdrIjp7Imt0eSI6IlJTQSIsIm4iOiIuLi4iLCJlIjoiAQABIn19.eyJodG0iOiJQT1NUIiwiaHR1IjoiaHR0cHM6Ly9pZHAuZXhhbXBsZS5jb20vdG9rZW4iLCJpYXQiOjE3MDAwMDAwMDAsImp0aSI6InU0LWJpZCJ9..sig`}</code></pre>
                        <pre class="glass-card" style="padding:12px;overflow:auto"><code>{`mermaid\nflowchart TD\n  A[Client] -- DPoP proof --> TE[Token Endpoint]\n  TE -->|cnf.jkt in token| AT[Access Token]\n  A -- DPoP proof + AT --> RS[Resource Server]\n  RS -->|verify sig, htm/htu, jti, ath| Allow`}</code></pre>
                        <p style="color:#9ba3b7;margin-top:8px">Servers commonly enforce replay windows on <code>jti</code> and may issue nonces. Resource calls MUST present a fresh proof per request.</p>
                    </>
                )
            }
            { slug === 'mtls' && (
                <>
                    <p style="color:#9ba3b7;margin:0 0 8px">RFC 8705 defines OAuth mTLS: client auth at AS and certificate‑bound access tokens at RS. Two auth modes: <code>tls_client_auth</code> (CA‑issued) and <code>self_signed_tls_client_auth</code>. Tokens carry <code>cnf</code> with <code>x5t#S256</code>.</p>
                    <pre class="glass-card" style="padding:12px;overflow:auto"><code>{`"cnf": {"x5t#S256": "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"}`}</code></pre>
                    <pre class="glass-card" style="padding:12px;overflow:auto"><code>{`mermaid\nsequenceDiagram\n  participant Client\n  participant AS as Authorization Server (mTLS)\n  participant RS as Resource Server (mTLS)\n  Client->>AS: TLS handshake (client cert) + /token\n  AS-->>Client: cert-bound access_token (cnf.x5t#S256)\n  Client->>RS: TLS handshake (same cert) + request\n  RS->>RS: Verify cert thumbprint matches token`}</code></pre>
                </>
            ) }
            { slug === 'dcr' && (
                <>
                    <p style="color:#9ba3b7;margin:0 0 8px">RFC 7591/7592 specify dynamic registration and management. Clients POST metadata (optionally with a <code>software_statement</code>) to <code>/register</code>, receive <code>client_id</code> (and secret). 7592 adds read/update/rotate.</p>
                    <pre class="glass-card" style="padding:12px;overflow:auto"><code>{`POST /register\n{\n  "redirect_uris": ["https://app.example.com/cb"],\n  "grant_types": ["authorization_code"],\n  "response_types": ["code"],\n  "token_endpoint_auth_method": "tls_client_auth",\n  "software_statement": "eyJ..."\n}`}</code></pre>
                    <pre class="glass-card" style="padding:12px;overflow:auto"><code>{`mermaid\nsequenceDiagram\n  participant Client\n  participant AS as Authorization Server\n  Client->>AS: POST /register (metadata)\n  AS-->>Client: 201 { client_id[, client_secret] }\n  Client->>AS: (7592) GET/PATCH/DELETE /register/{client_id}`}</code></pre>
                </>
            ) }
            { slug === 'authzen' && (
                <>
                    <p style="color:#9ba3b7;margin:0 0 8px">OpenID AuthZEN (OIDF) defines an authorization decision API and common data model to externalize fine‑grained authorization. It complements OAuth/OIDC by standardizing decision requests/responses (subject, action, resource, context) and obligations.</p>
                    <pre class="glass-card" style="padding:12px;overflow:auto"><code>{`mermaid\nsequenceDiagram\n  participant Client\n  participant PDP as AuthZ Decision Service\n  participant RS as Resource Server\n  Client->>PDP: evaluate(subject, action, resource, context)\n  PDP-->>Client: { decision, constraints, obligations }\n  Client->>RS: Enforce decision + constraints`}</code></pre>
                </>
            ) }
        </div>
    </section>
</Base>


